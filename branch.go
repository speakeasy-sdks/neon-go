// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"neon/pkg/models/operations"
	"neon/pkg/models/shared"
	"neon/pkg/utils"
	"net/http"
)

// branch - These methods allow you to create and manage branches in your Neon project. For related information, see [Manage branches](https://neon.tech/docs/manage/branches).
type branch struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newBranch(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *branch {
	return &branch{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// CreateProjectBranch - Create a branch
// Creates a branch in the specified project.
// You can obtain a `project_id` by listing the projects for your Neon account.
//
// This method does not require a request body, but you can specify one to create an endpoint for the branch or to select a non-default parent branch.
// The default behavior is to create a branch from the project's root branch (`main`) with no endpoint, and the branch name is auto-generated.
// For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
func (s *branch) CreateProjectBranch(ctx context.Context, projectID string, branchCreateRequest *shared.BranchCreateRequest) (*operations.CreateProjectBranchResponse, error) {
	request := operations.CreateProjectBranchRequest{
		ProjectID:           projectID,
		BranchCreateRequest: branchCreateRequest,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "BranchCreateRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	req.Header.Set("Content-Type", reqContentType)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateProjectBranchResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.CreateProjectBranch201ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.CreateProjectBranch201ApplicationJSONObject = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// CreateProjectBranchDatabase - Create a database
// Creates a database in the specified branch.
// A branch can have multiple databases.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain the `branch_id` by listing the project's branches.
// For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
func (s *branch) CreateProjectBranchDatabase(ctx context.Context, databaseCreateRequest shared.DatabaseCreateRequest, branchID string, projectID string) (*operations.CreateProjectBranchDatabaseResponse, error) {
	request := operations.CreateProjectBranchDatabaseRequest{
		DatabaseCreateRequest: databaseCreateRequest,
		BranchID:              branchID,
		ProjectID:             projectID,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}/databases", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "DatabaseCreateRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	req.Header.Set("Content-Type", reqContentType)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateProjectBranchDatabaseResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.DatabaseOperations
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.DatabaseOperations = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// CreateProjectBranchRole - Create a role
// Creates a role in the specified branch.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain the `branch_id` by listing the project's branches.
// In Neon, the terms "role" and "user" are synonymous.
// For related information, see [Manage users](https://neon.tech/docs/manage/users/).
//
// Connections established to the active read-write endpoint will be dropped.
// If the read-write endpoint is idle, the endpoint becomes active for a short period of time and is suspended afterward.
func (s *branch) CreateProjectBranchRole(ctx context.Context, roleCreateRequest shared.RoleCreateRequest, branchID string, projectID string) (*operations.CreateProjectBranchRoleResponse, error) {
	request := operations.CreateProjectBranchRoleRequest{
		RoleCreateRequest: roleCreateRequest,
		BranchID:          branchID,
		ProjectID:         projectID,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}/roles", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RoleCreateRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	req.Header.Set("Content-Type", reqContentType)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateProjectBranchRoleResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.RoleOperations
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.RoleOperations = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// DeleteProjectBranch - Delete a branch
// Deletes the specified branch from a project, and places
// all endpoints into an idle state, breaking existing client connections.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain a `branch_id` by listing the project's branches.
// For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
//
// When a successful response status is received, the endpoints are still active,
// and the branch is not yet deleted from storage.
// The deletion occurs after all operations finish.
// You cannot delete a branch if it is the only remaining branch in the project.
// A project must have at least one branch.
func (s *branch) DeleteProjectBranch(ctx context.Context, branchID string, projectID string) (*operations.DeleteProjectBranchResponse, error) {
	request := operations.DeleteProjectBranchRequest{
		BranchID:  branchID,
		ProjectID: projectID,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteProjectBranchResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.BranchOperations
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.BranchOperations = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// DeleteProjectBranchDatabase - Delete a database
// Deletes the specified database from the branch.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain the `branch_id` and `database_name` by listing branch's databases.
// For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
func (s *branch) DeleteProjectBranchDatabase(ctx context.Context, branchID string, databaseName string, projectID string) (*operations.DeleteProjectBranchDatabaseResponse, error) {
	request := operations.DeleteProjectBranchDatabaseRequest{
		BranchID:     branchID,
		DatabaseName: databaseName,
		ProjectID:    projectID,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}/databases/{database_name}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteProjectBranchDatabaseResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.DatabaseOperations
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.DatabaseOperations = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// DeleteProjectBranchRole - Delete a role
// Deletes the specified role from the branch.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain the `branch_id` by listing the project's branches.
// You can obtain the `role_name` by listing the roles for a branch.
// In Neon, the terms "role" and "user" are synonymous.
// For related information, see [Managing users](https://neon.tech/docs/manage/users/).
func (s *branch) DeleteProjectBranchRole(ctx context.Context, branchID string, projectID string, roleName string) (*operations.DeleteProjectBranchRoleResponse, error) {
	request := operations.DeleteProjectBranchRoleRequest{
		BranchID:  branchID,
		ProjectID: projectID,
		RoleName:  roleName,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}/roles/{role_name}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteProjectBranchRoleResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.RoleOperations
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.RoleOperations = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// GetProjectBranch - Get branch details
// Retrieves information about the specified branch.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain a `branch_id` by listing the project's branches.
// A `branch_id` value has a `br-` prefix.
//
// Each Neon project has a root branch named `main`.
// A project may contain child branches that were branched from `main` or from another branch.
// A parent branch is identified by a `parent_id` value, which is the `id` of the parent branch.
// For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
func (s *branch) GetProjectBranch(ctx context.Context, branchID string, projectID string) (*operations.GetProjectBranchResponse, error) {
	request := operations.GetProjectBranchRequest{
		BranchID:  branchID,
		ProjectID: projectID,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetProjectBranchResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.BranchResponse
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.BranchResponse = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// GetProjectBranchDatabase - Get database details
// Retrieves information about the specified database.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain the `branch_id` and `database_name` by listing branch's databases.
// For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
func (s *branch) GetProjectBranchDatabase(ctx context.Context, branchID string, databaseName string, projectID string) (*operations.GetProjectBranchDatabaseResponse, error) {
	request := operations.GetProjectBranchDatabaseRequest{
		BranchID:     branchID,
		DatabaseName: databaseName,
		ProjectID:    projectID,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}/databases/{database_name}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetProjectBranchDatabaseResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.DatabaseResponse
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.DatabaseResponse = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// GetProjectBranchRole - Get role details
// Retrieves details about the specified role.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain the `branch_id` by listing the project's branches.
// You can obtain the `role_name` by listing the roles for a branch.
// In Neon, the terms "role" and "user" are synonymous.
// For related information, see [Managing users](https://neon.tech/docs/manage/users/).
func (s *branch) GetProjectBranchRole(ctx context.Context, branchID string, projectID string, roleName string) (*operations.GetProjectBranchRoleResponse, error) {
	request := operations.GetProjectBranchRoleRequest{
		BranchID:  branchID,
		ProjectID: projectID,
		RoleName:  roleName,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}/roles/{role_name}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetProjectBranchRoleResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.RoleResponse
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.RoleResponse = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// GetProjectBranchRolePassword - Get role password
// Retrieves password of the specified role if possible.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain the `branch_id` by listing the project's branches.
// You can obtain the `role_name` by listing the roles for a branch.
// In Neon, the terms "role" and "user" are synonymous.
// For related information, see [Managing users](https://neon.tech/docs/manage/users/).
func (s *branch) GetProjectBranchRolePassword(ctx context.Context, branchID string, projectID string, roleName string) (*operations.GetProjectBranchRolePasswordResponse, error) {
	request := operations.GetProjectBranchRolePasswordRequest{
		BranchID:  branchID,
		ProjectID: projectID,
		RoleName:  roleName,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}/roles/{role_name}/reveal_password", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetProjectBranchRolePasswordResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.RolePasswordResponse
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.RolePasswordResponse = out
		}
	case httpRes.StatusCode == 404:
		fallthrough
	case httpRes.StatusCode == 412:
		fallthrough
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// ListProjectBranchDatabases - Get a list of databases
// Retrieves a list of databases for the specified branch.
// A branch can have multiple databases.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain the `branch_id` by listing the project's branches.
// For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
func (s *branch) ListProjectBranchDatabases(ctx context.Context, branchID string, projectID string) (*operations.ListProjectBranchDatabasesResponse, error) {
	request := operations.ListProjectBranchDatabasesRequest{
		BranchID:  branchID,
		ProjectID: projectID,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}/databases", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListProjectBranchDatabasesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.DatabasesResponse
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.DatabasesResponse = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// ListProjectBranchEndpoints - Get a list of branch endpoints
// Retrieves a list of endpoints for the specified branch.
// Currently, Neon permits only one endpoint per branch.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain the `branch_id` by listing the project's branches.
func (s *branch) ListProjectBranchEndpoints(ctx context.Context, branchID string, projectID string) (*operations.ListProjectBranchEndpointsResponse, error) {
	request := operations.ListProjectBranchEndpointsRequest{
		BranchID:  branchID,
		ProjectID: projectID,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}/endpoints", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListProjectBranchEndpointsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.EndpointsResponse
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.EndpointsResponse = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// ListProjectBranchRoles - Get a list of roles
// Retrieves a list of roles from the specified branch.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain the `branch_id` by listing the project's branches.
// In Neon, the terms "role" and "user" are synonymous.
// For related information, see [Manage users](https://neon.tech/docs/manage/users/).
func (s *branch) ListProjectBranchRoles(ctx context.Context, branchID string, projectID string) (*operations.ListProjectBranchRolesResponse, error) {
	request := operations.ListProjectBranchRolesRequest{
		BranchID:  branchID,
		ProjectID: projectID,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}/roles", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListProjectBranchRolesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.RolesResponse
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.RolesResponse = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// ListProjectBranches - Get a list of branches
// Retrieves a list of branches for the specified project.
// You can obtain a `project_id` by listing the projects for your Neon account.
//
// Each Neon project has a root branch named `main`.
// A `branch_id` value has a `br-` prefix.
// A project may contain child branches that were branched from `main` or from another branch.
// A parent branch is identified by the `parent_id` value, which is the `id` of the parent branch.
// For related information, see [Manage branches](https://neon.tech/docs/manage/branches/).
func (s *branch) ListProjectBranches(ctx context.Context, projectID string) (*operations.ListProjectBranchesResponse, error) {
	request := operations.ListProjectBranchesRequest{
		ProjectID: projectID,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListProjectBranchesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.BranchesResponse
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.BranchesResponse = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// ResetProjectBranchRolePassword - Reset the role password
// Resets the password for the specified role.
// Returns a new password and operations. The new password is ready to use when the last operation finishes.
// The old password remains valid until last operation finishes.
// Connections to the read-write endpoint are dropped. If idle,
// the read-write endpoint becomes active for a short period of time.
//
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain the `branch_id` by listing the project's branches.
// You can obtain the `role_name` by listing the roles for a branch.
// In Neon, the terms "role" and "user" are synonymous.
// For related information, see [Managing users](https://neon.tech/docs/manage/users/).
func (s *branch) ResetProjectBranchRolePassword(ctx context.Context, branchID string, projectID string, roleName string) (*operations.ResetProjectBranchRolePasswordResponse, error) {
	request := operations.ResetProjectBranchRolePasswordRequest{
		BranchID:  branchID,
		ProjectID: projectID,
		RoleName:  roleName,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}/roles/{role_name}/reset_password", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ResetProjectBranchRolePasswordResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.RoleOperations
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.RoleOperations = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// SetPrimaryProjectBranch - Set the branch as the primary branch of a project
// The primary mark is automatically removed from the previous primary branch.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain the `branch_id` by listing the project's branches.
// For more information, see [Manage branches](https://neon.tech/docs/manage/branches/).
func (s *branch) SetPrimaryProjectBranch(ctx context.Context, branchID string, projectID string) (*operations.SetPrimaryProjectBranchResponse, error) {
	request := operations.SetPrimaryProjectBranchRequest{
		BranchID:  branchID,
		ProjectID: projectID,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}/set_as_primary", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.SetPrimaryProjectBranchResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.BranchOperations
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.BranchOperations = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// UpdateProjectBranch - Update a branch
// Updates the specified branch. Only changing the branch name is supported.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain the `branch_id` by listing the project's branches.
// For more information, see [Manage branches](https://neon.tech/docs/manage/branches/).
func (s *branch) UpdateProjectBranch(ctx context.Context, branchUpdateRequest shared.BranchUpdateRequest, branchID string, projectID string) (*operations.UpdateProjectBranchResponse, error) {
	request := operations.UpdateProjectBranchRequest{
		BranchUpdateRequest: branchUpdateRequest,
		BranchID:            branchID,
		ProjectID:           projectID,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "BranchUpdateRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	req.Header.Set("Content-Type", reqContentType)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateProjectBranchResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.BranchOperations
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.BranchOperations = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// UpdateProjectBranchDatabase - Update a database
// Updates the specified database in the branch.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain the `branch_id` and `database_name` by listing the branch's databases.
// For related information, see [Manage databases](https://neon.tech/docs/manage/databases/).
func (s *branch) UpdateProjectBranchDatabase(ctx context.Context, databaseUpdateRequest shared.DatabaseUpdateRequest, branchID string, databaseName string, projectID string) (*operations.UpdateProjectBranchDatabaseResponse, error) {
	request := operations.UpdateProjectBranchDatabaseRequest{
		DatabaseUpdateRequest: databaseUpdateRequest,
		BranchID:              branchID,
		DatabaseName:          databaseName,
		ProjectID:             projectID,
	}

	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/branches/{branch_id}/databases/{database_name}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "DatabaseUpdateRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s", s.language, s.sdkVersion, s.genVersion))

	req.Header.Set("Content-Type", reqContentType)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateProjectBranchDatabaseResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.DatabaseOperations
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.DatabaseOperations = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}
