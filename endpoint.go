// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"neon/pkg/models/operations"
	"neon/pkg/models/shared"
	"neon/pkg/utils"
	"net/http"
)

// endpoint - These methods allow you to create and manage compute endpoints in your Neon project. For related information, see [Manage compute endpoints](https://neon.tech/docs/manage/endpoints).
type endpoint struct {
	sdkConfiguration sdkConfiguration
}

func newEndpoint(sdkConfig sdkConfiguration) *endpoint {
	return &endpoint{
		sdkConfiguration: sdkConfig,
	}
}

// CreateProjectEndpoint - Create an endpoint
// Creates an endpoint for the specified branch.
// An endpoint is a Neon compute instance.
// There is a maximum of one endpoint per branch.
// If the specified branch already has an endpoint, the operation fails.
//
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain `branch_id` by listing the project's branches.
// A `branch_id` has a `br-` prefix.
// Currently, only the `read_write` endpoint type is supported.
// For supported regions and `region_id` values, see [Regions](https://neon.tech/docs/introduction/regions/).
// For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
func (s *endpoint) CreateProjectEndpoint(ctx context.Context, endpointCreateRequest shared.EndpointCreateRequest, projectID string) (*operations.CreateProjectEndpointResponse, error) {
	request := operations.CreateProjectEndpointRequest{
		EndpointCreateRequest: endpointCreateRequest,
		ProjectID:             projectID,
	}

	baseURL := utils.ReplaceParameters(s.sdkConfiguration.GetServerDetails())
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/endpoints", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "EndpointCreateRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s %s", s.sdkConfiguration.Language, s.sdkConfiguration.SDKVersion, s.sdkConfiguration.GenVersion, s.sdkConfiguration.OpenAPIDocVersion))

	req.Header.Set("Content-Type", reqContentType)

	client := s.sdkConfiguration.SecurityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.CreateProjectEndpointResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.EndpointOperations
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.EndpointOperations = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// DeleteProjectEndpoint - Delete an endpoint
// Delete the specified endpoint.
// An endpoint is a Neon compute instance.
// Deleting an endpoint drops existing network connections to the endpoint.
// The deletion is completed when last operation in the chain finishes successfully.
//
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain an `endpoint_id` by listing your project's endpoints.
// An `endpoint_id` has an `ep-` prefix.
// For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
func (s *endpoint) DeleteProjectEndpoint(ctx context.Context, endpointID string, projectID string) (*operations.DeleteProjectEndpointResponse, error) {
	request := operations.DeleteProjectEndpointRequest{
		EndpointID: endpointID,
		ProjectID:  projectID,
	}

	baseURL := utils.ReplaceParameters(s.sdkConfiguration.GetServerDetails())
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/endpoints/{endpoint_id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "DELETE", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s %s", s.sdkConfiguration.Language, s.sdkConfiguration.SDKVersion, s.sdkConfiguration.GenVersion, s.sdkConfiguration.OpenAPIDocVersion))

	client := s.sdkConfiguration.SecurityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.DeleteProjectEndpointResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.EndpointOperations
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.EndpointOperations = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// GetProjectEndpoint - Get an endpoint
// Retrieves information about the specified endpoint.
// An endpoint is a Neon compute instance.
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain an `endpoint_id` by listing your project's endpoints.
// An `endpoint_id` has an `ep-` prefix.
// For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
func (s *endpoint) GetProjectEndpoint(ctx context.Context, endpointID string, projectID string) (*operations.GetProjectEndpointResponse, error) {
	request := operations.GetProjectEndpointRequest{
		EndpointID: endpointID,
		ProjectID:  projectID,
	}

	baseURL := utils.ReplaceParameters(s.sdkConfiguration.GetServerDetails())
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/endpoints/{endpoint_id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s %s", s.sdkConfiguration.Language, s.sdkConfiguration.SDKVersion, s.sdkConfiguration.GenVersion, s.sdkConfiguration.OpenAPIDocVersion))

	client := s.sdkConfiguration.SecurityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetProjectEndpointResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.EndpointResponse
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.EndpointResponse = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// ListProjectEndpoints - Get a list of endpoints
// Retrieves a list of endpoints for the specified project.
// An endpoint is a Neon compute instance.
// You can obtain a `project_id` by listing the projects for your Neon account.
// For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
func (s *endpoint) ListProjectEndpoints(ctx context.Context, projectID string) (*operations.ListProjectEndpointsResponse, error) {
	request := operations.ListProjectEndpointsRequest{
		ProjectID: projectID,
	}

	baseURL := utils.ReplaceParameters(s.sdkConfiguration.GetServerDetails())
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/endpoints", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s %s", s.sdkConfiguration.Language, s.sdkConfiguration.SDKVersion, s.sdkConfiguration.GenVersion, s.sdkConfiguration.OpenAPIDocVersion))

	client := s.sdkConfiguration.SecurityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListProjectEndpointsResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.EndpointsResponse
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.EndpointsResponse = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// StartProjectEndpoint - Start an endpoint
// Starts an endpoint. The endpoint is ready to use
// after the last operation in chain finishes successfully.
//
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain an `endpoint_id` by listing your project's endpoints.
// An `endpoint_id` has an `ep-` prefix.
// For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
func (s *endpoint) StartProjectEndpoint(ctx context.Context, endpointID string, projectID string) (*operations.StartProjectEndpointResponse, error) {
	request := operations.StartProjectEndpointRequest{
		EndpointID: endpointID,
		ProjectID:  projectID,
	}

	baseURL := utils.ReplaceParameters(s.sdkConfiguration.GetServerDetails())
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/endpoints/{endpoint_id}/start", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s %s", s.sdkConfiguration.Language, s.sdkConfiguration.SDKVersion, s.sdkConfiguration.GenVersion, s.sdkConfiguration.OpenAPIDocVersion))

	client := s.sdkConfiguration.SecurityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.StartProjectEndpointResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.EndpointOperations
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.EndpointOperations = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// SuspendProjectEndpoint - Suspend an endpoint
// Suspend the specified endpoint
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain an `endpoint_id` by listing your project's endpoints.
// An `endpoint_id` has an `ep-` prefix.
// For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
func (s *endpoint) SuspendProjectEndpoint(ctx context.Context, endpointID string, projectID string) (*operations.SuspendProjectEndpointResponse, error) {
	request := operations.SuspendProjectEndpointRequest{
		EndpointID: endpointID,
		ProjectID:  projectID,
	}

	baseURL := utils.ReplaceParameters(s.sdkConfiguration.GetServerDetails())
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/endpoints/{endpoint_id}/suspend", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s %s", s.sdkConfiguration.Language, s.sdkConfiguration.SDKVersion, s.sdkConfiguration.GenVersion, s.sdkConfiguration.OpenAPIDocVersion))

	client := s.sdkConfiguration.SecurityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.SuspendProjectEndpointResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.EndpointOperations
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.EndpointOperations = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}

// UpdateProjectEndpoint - Update an endpoint
// Updates the specified endpoint. Currently, only changing the associated branch is supported.
// The branch that you specify cannot have an existing endpoint.
//
// You can obtain a `project_id` by listing the projects for your Neon account.
// You can obtain an `endpoint_id` and `branch_id` by listing your project's endpoints.
// An `endpoint_id` has an `ep-` prefix. A `branch_id` has a `br-` prefix.
// For more information about endpoints, see [Manage endpoints](https://neon.tech/docs/manage/endpoints/).
//
// If the returned list of operations is not empty, the endpoint is not ready to use.
// The client must wait for the last operation to finish before using the endpoint.
// If the endpoint was idle before the update, the endpoint becomes active for a short period of time,
// and the control plane suspends it again after the update.
func (s *endpoint) UpdateProjectEndpoint(ctx context.Context, endpointUpdateRequest shared.EndpointUpdateRequest, endpointID string, projectID string) (*operations.UpdateProjectEndpointResponse, error) {
	request := operations.UpdateProjectEndpointRequest{
		EndpointUpdateRequest: endpointUpdateRequest,
		EndpointID:            endpointID,
		ProjectID:             projectID,
	}

	baseURL := utils.ReplaceParameters(s.sdkConfiguration.GetServerDetails())
	url, err := utils.GenerateURL(ctx, baseURL, "/projects/{project_id}/endpoints/{endpoint_id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "EndpointUpdateRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	req.Header.Set("Accept", "application/json;q=1, application/json;q=0")
	req.Header.Set("user-agent", fmt.Sprintf("speakeasy-sdk/%s %s %s %s", s.sdkConfiguration.Language, s.sdkConfiguration.SDKVersion, s.sdkConfiguration.GenVersion, s.sdkConfiguration.OpenAPIDocVersion))

	req.Header.Set("Content-Type", reqContentType)

	client := s.sdkConfiguration.SecurityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}

	rawBody, err := io.ReadAll(httpRes.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response body: %w", err)
	}
	httpRes.Body.Close()
	httpRes.Body = io.NopCloser(bytes.NewBuffer(rawBody))

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateProjectEndpointResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.EndpointOperations
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.EndpointOperations = out
		}
	default:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GeneralError
			if err := utils.UnmarshalJsonFromResponseBody(bytes.NewBuffer(rawBody), &out); err != nil {
				return nil, err
			}

			res.GeneralError = out
		}
	}

	return res, nil
}
